<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/knowmyspot/HistoryStorage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/knowmyspot/HistoryStorage.kt" />
              <option name="updatedContent" value="package com.example.knowmyspot&#10;&#10;data class HistoryItem(&#10;    val latitude: Double,&#10;    val longitude: Double,&#10;    val weather: String,&#10;    val note: String? = null,&#10;    val timestamp: Long = System.currentTimeMillis()&#10;)&#10;&#10;object HistoryStorage {&#10;    val items = mutableListOf&lt;HistoryItem&gt;()&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/knowmyspot/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/knowmyspot/MainActivity.kt" />
              <option name="originalContent" value="package com.example.knowmyspot&#10;&#10;import android.Manifest&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.location.Geocoder&#10;import android.location.Location&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.View&#10;import android.widget.Button&#10;import android.widget.ImageButton&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.annotation.RequiresPermission&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.example.knowmyspot.data.LocationRecord&#10;import com.google.android.gms.location.FusedLocationProviderClient&#10;import com.google.android.gms.location.LocationServices&#10;import com.google.android.gms.location.Priority&#10;import com.google.android.gms.tasks.CancellationTokenSource&#10;import kotlinx.coroutines.launch&#10;import retrofit2.Call&#10;import retrofit2.Callback&#10;import retrofit2.Response&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import retrofit2.http.GET&#10;import retrofit2.http.Query&#10;import java.io.IOException&#10;import java.util.*&#10;import android.os.Looper&#10;import com.google.android.gms.location.LocationCallback&#10;import com.google.android.gms.location.LocationRequest&#10;import com.google.android.gms.location.LocationResult&#10;&#10;class MainActivity : AppCompatActivity() {&#10;    private lateinit var fusedLocationClient: FusedLocationProviderClient&#10;    private lateinit var tvLocation: TextView&#10;    private lateinit var tvCoordinates: TextView&#10;    private lateinit var tvWeather: TextView&#10;    private lateinit var btnRefresh: ImageButton&#10;    private lateinit var btnSave: ImageButton&#10;    private lateinit var progressBar: ProgressBar&#10;    private lateinit var geocoder: Geocoder&#10;&#10;    private val repository by lazy { (application as LocationApplication).repository }&#10;&#10;    private var lastLat: Double? = null&#10;    private var lastLon: Double? = null&#10;    private var lastAddress: String? = null&#10;    private var lastWeather: String? = null&#10;    private val weatherApiKey = &quot;daf995ddd2e62368f8cb8e6151c40a4e&quot;&#10;    private val weatherApi: WeatherApi by lazy {&#10;        Retrofit.Builder()&#10;            .baseUrl(&quot;https://api.openweathermap.org/data/2.5/&quot;)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;            .create(WeatherApi::class.java)&#10;    }&#10;&#10;    @RequiresPermission(allOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_main)&#10;&#10;        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)&#10;        tvLocation = findViewById(R.id.tvLocation)&#10;        tvCoordinates = findViewById(R.id.tvCoordinates)&#10;        tvWeather = findViewById(R.id.tvWeather)&#10;        btnRefresh = findViewById(R.id.btnRefresh)&#10;        progressBar = findViewById(R.id.progressBar)&#10;        geocoder = Geocoder(this, Locale.getDefault())&#10;        btnSave = findViewById(R.id.btnSave)&#10;&#10;        findViewById&lt;Button&gt;(R.id.btnHistory).setOnClickListener {&#10;            startActivity(Intent(this, HistoryActivity::class.java))&#10;        }&#10;        findViewById&lt;Button&gt;(R.id.btnSettings).setOnClickListener {&#10;            startActivity(Intent(this, SettingsActivity::class.java))&#10;        }&#10;&#10;        btnRefresh.setOnClickListener {&#10;            getLastLocation(false)&#10;        }&#10;        btnSave.setOnClickListener {&#10;            saveCurrentLocation()&#10;        }&#10;        getLastLocation(true)&#10;    }&#10;&#10;    @RequiresPermission(allOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Znovu načte polohu a počasí pro případ, že se změnilo nastavení (např. jednotky)&#10;        getLastLocation(false)&#10;    }&#10;&#10;    @RequiresPermission(anyOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    private fun getLastLocation(shouldSave: Boolean) {&#10;        btnRefresh.visibility = View.GONE&#10;        progressBar.visibility = View.VISIBLE&#10;        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp;&#10;            ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {&#10;            // Žádej obě oprávnění, aby uživatel mohl zvolit přesnou i přibližnou polohu&#10;            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION), 100)&#10;            progressBar.visibility = View.GONE&#10;            btnRefresh.visibility = View.VISIBLE&#10;            return&#10;        }&#10;        fusedLocationClient.lastLocation.addOnSuccessListener { location: Location? -&gt;&#10;            if (location != null) {&#10;                handleLocation(location, shouldSave)&#10;            } else {&#10;                // Fallback: získej aktuální polohu (lastLocation bývá null na čerstvě spuštěném zařízení/emulátoru)&#10;                fetchCurrentLocation(shouldSave)&#10;            }&#10;        }.addOnFailureListener { e -&gt;&#10;            Log.e(&quot;Location&quot;, &quot;lastLocation selhalo: ${e.message}&quot;, e)&#10;            fetchCurrentLocation(shouldSave)&#10;        }&#10;    }&#10;&#10;    private fun fetchCurrentLocation(shouldSave: Boolean) {&#10;        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp;&#10;            ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {&#10;            progressBar.visibility = View.GONE&#10;            btnRefresh.visibility = View.VISIBLE&#10;            return&#10;        }&#10;        val cts = CancellationTokenSource()&#10;        fusedLocationClient.getCurrentLocation(Priority.PRIORITY_HIGH_ACCURACY, cts.token)&#10;            .addOnSuccessListener { location -&gt;&#10;                if (location != null) {&#10;                    handleLocation(location, shouldSave)&#10;                } else {&#10;                    // Pokud nevrátí aktuální polohu, požádej o jediný update&#10;                    requestSingleLocationUpdate(shouldSave)&#10;                }&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.e(&quot;Location&quot;, &quot;getCurrentLocation selhalo: ${e.message}&quot;, e)&#10;                requestSingleLocationUpdate(shouldSave)&#10;            }&#10;    }&#10;&#10;    private fun requestSingleLocationUpdate(shouldSave: Boolean) {&#10;        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp;&#10;            ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {&#10;            progressBar.visibility = View.GONE&#10;            btnRefresh.visibility = View.VISIBLE&#10;            return&#10;        }&#10;        val request = LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 1000L)&#10;            .setMinUpdateIntervalMillis(0L)&#10;            .setMaxUpdateDelayMillis(1000L)&#10;            .setGranularity(com.google.android.gms.location.Granularity.GRANULARITY_PERMISSION_LEVEL)&#10;            .setMaxUpdates(1)&#10;            .build()&#10;&#10;        val callback = object : LocationCallback() {&#10;            override fun onLocationResult(result: LocationResult) {&#10;                fusedLocationClient.removeLocationUpdates(this)&#10;                val loc = result.lastLocation&#10;                if (loc != null) {&#10;                    handleLocation(loc, shouldSave)&#10;                } else {&#10;                    tvLocation.text = &quot;Poloha není dostupná&quot;&#10;                    tvWeather.text = &quot;Počasí: --&quot;&#10;                    progressBar.visibility = View.GONE&#10;                    btnRefresh.visibility = View.VISIBLE&#10;                }&#10;            }&#10;        }&#10;        fusedLocationClient.requestLocationUpdates(request, callback, Looper.getMainLooper())&#10;    }&#10;&#10;    private fun handleLocation(location: Location, shouldSave: Boolean) {&#10;        lastLat = location.latitude&#10;        lastLon = location.longitude&#10;        tvCoordinates.text = &quot;Lat: %.5f, Lon: %.5f&quot;.format(location.latitude, location.longitude)&#10;        lifecycleScope.launch {&#10;            val address = getAddressFromLocation(location)&#10;            tvLocation.text = address ?: &quot;Adresa nenalezena&quot;&#10;            lastAddress = address&#10;            getWeather(address, shouldSave)&#10;        }&#10;    }&#10;&#10;    private fun getWeather(address: String?, shouldSave: Boolean) {&#10;        val lat = lastLat&#10;        val lon = lastLon&#10;        if (lat == null || lon == null) {&#10;            tvWeather.text = &quot;Počasí: --&quot;&#10;            Log.e(&quot;Weather&quot;, &quot;Souřadnice nejsou k dispozici&quot;)&#10;            progressBar.visibility = View.GONE&#10;            btnRefresh.visibility = View.VISIBLE&#10;            return&#10;        }&#10;&#10;        val sharedPreferences = getSharedPreferences(&quot;settings&quot;, MODE_PRIVATE)&#10;        val unit = sharedPreferences.getString(&quot;unit&quot;, &quot;metric&quot;) ?: &quot;metric&quot;&#10;&#10;        weatherApi.getWeather(lat, lon, weatherApiKey, unit).enqueue(object : Callback&lt;WeatherResponse&gt; {&#10;            override fun onResponse(call: Call&lt;WeatherResponse&gt;, response: Response&lt;WeatherResponse&gt;) {&#10;                if (!response.isSuccessful) {&#10;                    tvWeather.text = &quot;Počasí: --&quot;&#10;                    Log.e(&quot;Weather&quot;, &quot;Chyba HTTP: ${response.code()} ${response.message()}&quot;)&#10;                    progressBar.visibility = View.GONE&#10;                    btnRefresh.visibility = View.VISIBLE&#10;                    return&#10;                }&#10;                val body = response.body()&#10;                if (body != null) {&#10;                    val desc = body.weather.firstOrNull()?.description ?: &quot;--&quot;&#10;                    val temp = body.main.temp&#10;                    val unitSymbol = if (unit == &quot;imperial&quot;) &quot;°F&quot; else &quot;°C&quot;&#10;                    val weatherText = &quot;Počasí: $temp$unitSymbol, $desc&quot;&#10;                    tvWeather.text = weatherText&#10;                    lastWeather = weatherText&#10;                    // Uložení do historie&#10;                    if (shouldSave) {&#10;                        val lat = lastLat&#10;                        val lon = lastLon&#10;                        if (lat != null &amp;&amp; lon != null) {&#10;                            val defaultNote = sharedPreferences.getString(&quot;default_note&quot;, &quot;&quot;)&#10;                            lifecycleScope.launch {&#10;                                repository.insert(&#10;                                    LocationRecord(&#10;                                        latitude = lat,&#10;                                        longitude = lon,&#10;                                        timestamp = System.currentTimeMillis(),&#10;                                        address = address ?: &quot;Neznámá adresa&quot;,&#10;                                        weather = weatherText,&#10;                                        note = defaultNote&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                    Log.d(&quot;Weather&quot;, &quot;Úspěch: $temp$unitSymbol, $desc&quot;)&#10;                } else {&#10;                    tvWeather.text = &quot;Počasí: --&quot;&#10;                    Log.e(&quot;Weather&quot;, &quot;Tělo odpovědi je null&quot;)&#10;                }&#10;                progressBar.visibility = View.GONE&#10;                btnRefresh.visibility = View.VISIBLE&#10;            }&#10;            override fun onFailure(call: Call&lt;WeatherResponse&gt;, t: Throwable) {&#10;                tvWeather.text = &quot;Počasí: --&quot;&#10;                Log.e(&quot;Weather&quot;, &quot;Chyba volání: ${t.message}&quot;, t)&#10;                progressBar.visibility = View.GONE&#10;                btnRefresh.visibility = View.VISIBLE&#10;            }&#10;        })&#10;    }&#10;&#10;    private fun saveCurrentLocation() {&#10;        if (lastLat != null &amp;&amp; lastLon != null &amp;&amp; lastAddress != null) {&#10;            val sharedPreferences = getSharedPreferences(&quot;settings&quot;, MODE_PRIVATE)&#10;            val defaultNote = sharedPreferences.getString(&quot;default_note&quot;, &quot;&quot;)&#10;            val record = LocationRecord(&#10;                latitude = lastLat!!,&#10;                longitude = lastLon!!,&#10;                timestamp = System.currentTimeMillis(),&#10;                address = lastAddress!!,&#10;                weather = lastWeather,&#10;                note = defaultNote&#10;            )&#10;            lifecycleScope.launch {&#10;                repository.insert(record)&#10;                Toast.makeText(this@MainActivity, &quot;Poloha uložena&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        } else {&#10;            Toast.makeText(this, &quot;Nelze uložit, data o poloze nejsou k dispozici.&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    @RequiresPermission(allOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;        if (requestCode == 100) {&#10;            val fineGranted = ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED&#10;            val coarseGranted = ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED&#10;            if (fineGranted || coarseGranted) {&#10;                getLastLocation(true)&#10;            } else {&#10;                Toast.makeText(this, &quot;Bez povolení polohy nelze získat souřadnice.&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getAddressFromLocation(location: Location): String? {&#10;        return try {&#10;            val addresses = geocoder.getFromLocation(location.latitude, location.longitude, 1)&#10;            if (addresses?.isNotEmpty() == true) {&#10;                addresses[0].getAddressLine(0)&#10;            } else null&#10;        } catch (e: IOException) {&#10;            Log.e(&quot;Geocoder&quot;, &quot;Nelze získat adresu&quot;, e)&#10;            null&#10;        }&#10;    }&#10;}&#10;&#10;// --- OpenWeatherMap API rozhraní ---&#10;interface WeatherApi {&#10;    @GET(&quot;weather&quot;)&#10;    fun getWeather(&#10;        @Query(&quot;lat&quot;) lat: Double,&#10;        @Query(&quot;lon&quot;) lon: Double,&#10;        @Query(&quot;appid&quot;) apiKey: String,&#10;        @Query(&quot;units&quot;) units: String,&#10;        @Query(&quot;lang&quot;) lang: String = &quot;cz&quot;&#10;    ): Call&lt;WeatherResponse&gt;&#10;}&#10;&#10;data class WeatherResponse(&#10;    val weather: List&lt;WeatherDesc&gt;,&#10;    val main: MainWeather&#10;)&#10;data class WeatherDesc(val description: String)&#10;data class MainWeather(val temp: Double)&#10;" />
              <option name="updatedContent" value="package com.example.knowmyspot&#10;&#10;import android.Manifest&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.location.Geocoder&#10;import android.location.Location&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.View&#10;import android.widget.Button&#10;import android.widget.ImageButton&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.annotation.RequiresPermission&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.example.knowmyspot.data.LocationRecord&#10;import com.google.android.gms.location.FusedLocationProviderClient&#10;import com.google.android.gms.location.LocationServices&#10;import com.google.android.gms.location.Priority&#10;import com.google.android.gms.tasks.CancellationTokenSource&#10;import kotlinx.coroutines.launch&#10;import retrofit2.Call&#10;import retrofit2.Callback&#10;import retrofit2.Response&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import retrofit2.http.GET&#10;import retrofit2.http.Query&#10;import java.io.IOException&#10;import java.util.*&#10;import android.os.Looper&#10;import com.google.android.gms.location.LocationCallback&#10;import com.google.android.gms.location.LocationRequest&#10;import com.google.android.gms.location.LocationResult&#10;&#10;class MainActivity : AppCompatActivity() {&#10;    private lateinit var fusedLocationClient: FusedLocationProviderClient&#10;    private lateinit var tvLocation: TextView&#10;    private lateinit var tvCoordinates: TextView&#10;    private lateinit var tvWeather: TextView&#10;    private lateinit var btnRefresh: ImageButton&#10;    private lateinit var btnSave: ImageButton&#10;    private lateinit var progressBar: ProgressBar&#10;    private lateinit var geocoder: Geocoder&#10;&#10;    private val repository by lazy { (application as LocationApplication).repository }&#10;&#10;    private var lastLat: Double? = null&#10;    private var lastLon: Double? = null&#10;    private var lastAddress: String? = null&#10;    private var lastWeather: String? = null&#10;    private val weatherApiKey = &quot;daf995ddd2e62368f8cb8e6151c40a4e&quot;&#10;    private val weatherApi: WeatherApi by lazy {&#10;        Retrofit.Builder()&#10;            .baseUrl(&quot;https://api.openweathermap.org/data/2.5/&quot;)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;            .create(WeatherApi::class.java)&#10;    }&#10;&#10;    @RequiresPermission(allOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_main)&#10;&#10;        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)&#10;        tvLocation = findViewById(R.id.tvLocation)&#10;        tvCoordinates = findViewById(R.id.tvCoordinates)&#10;        tvWeather = findViewById(R.id.tvWeather)&#10;        btnRefresh = findViewById(R.id.btnRefresh)&#10;        progressBar = findViewById(R.id.progressBar)&#10;        geocoder = Geocoder(this, Locale.getDefault())&#10;        btnSave = findViewById(R.id.btnSave)&#10;&#10;        findViewById&lt;Button&gt;(R.id.btnHistory).setOnClickListener {&#10;            startActivity(Intent(this, HistoryActivity::class.java))&#10;        }&#10;        findViewById&lt;Button&gt;(R.id.btnSettings).setOnClickListener {&#10;            startActivity(Intent(this, SettingsActivity::class.java))&#10;        }&#10;&#10;        btnRefresh.setOnClickListener {&#10;            getLastLocation(false)&#10;        }&#10;        btnSave.setOnClickListener {&#10;            saveCurrentLocation()&#10;        }&#10;        getLastLocation(true)&#10;    }&#10;&#10;    @RequiresPermission(allOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Znovu načte polohu a počasí pro případ, že se změnilo nastavení (např. jednotky)&#10;        getLastLocation(false)&#10;    }&#10;&#10;    @RequiresPermission(anyOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    private fun getLastLocation(shouldSave: Boolean) {&#10;        btnRefresh.visibility = View.GONE&#10;        progressBar.visibility = View.VISIBLE&#10;        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp;&#10;            ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {&#10;            // Žádej obě oprávnění, aby uživatel mohl zvolit přesnou i přibližnou polohu&#10;            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION), 100)&#10;            progressBar.visibility = View.GONE&#10;            btnRefresh.visibility = View.VISIBLE&#10;            return&#10;        }&#10;        fusedLocationClient.lastLocation.addOnSuccessListener { location: Location? -&gt;&#10;            if (location != null) {&#10;                val isRecent = isRecentLocation(location)&#10;                val accText = if (location.hasAccuracy()) &quot; acc=${location.accuracy}&quot; else &quot;&quot;&#10;                Log.d(&quot;Location&quot;, &quot;lastLocation t=${location.time}$accText recent=$isRecent lat=${location.latitude} lon=${location.longitude}&quot;)&#10;                if (isRecent) {&#10;                    handleLocation(location, shouldSave)&#10;                } else {&#10;                    // Zastaralá poloha – získej novou&#10;                    fetchCurrentLocation(shouldSave)&#10;                }&#10;            } else {&#10;                // Fallback: získej aktuální polohu (lastLocation bývá null na čerstvě spuštěném zařízení/emulátoru)&#10;                fetchCurrentLocation(shouldSave)&#10;            }&#10;        }.addOnFailureListener { e -&gt;&#10;            Log.e(&quot;Location&quot;, &quot;lastLocation selhalo: ${e.message}&quot;, e)&#10;            fetchCurrentLocation(shouldSave)&#10;        }&#10;    }&#10;&#10;    private fun isRecentLocation(location: Location, maxAgeMs: Long = 10_000L): Boolean {&#10;        return System.currentTimeMillis() - location.time &lt;= maxAgeMs&#10;    }&#10;&#10;    private fun effectivePriority(): Int {&#10;        val fineGranted = ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED&#10;        return if (fineGranted) Priority.PRIORITY_HIGH_ACCURACY else Priority.PRIORITY_BALANCED_POWER_ACCURACY&#10;    }&#10;&#10;    private fun fetchCurrentLocation(shouldSave: Boolean) {&#10;        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp;&#10;            ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {&#10;            progressBar.visibility = View.GONE&#10;            btnRefresh.visibility = View.VISIBLE&#10;            return&#10;        }&#10;        val priority = effectivePriority()&#10;        val cts = CancellationTokenSource()&#10;        fusedLocationClient.getCurrentLocation(priority, cts.token)&#10;            .addOnSuccessListener { location -&gt;&#10;                if (location != null) {&#10;                    Log.d(&quot;Location&quot;, &quot;getCurrentLocation lat=${location.latitude} lon=${location.longitude} t=${location.time} acc=${location.accuracy}&quot;)&#10;                    handleLocation(location, shouldSave)&#10;                } else {&#10;                    // Pokud nevrátí aktuální polohu, požádej o krátké aktivní updaty&#10;                    requestSingleLocationUpdate(shouldSave)&#10;                }&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.e(&quot;Location&quot;, &quot;getCurrentLocation selhalo: ${e.message}&quot;, e)&#10;                requestSingleLocationUpdate(shouldSave)&#10;            }&#10;    }&#10;&#10;    private fun requestSingleLocationUpdate(shouldSave: Boolean) {&#10;        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp;&#10;            ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {&#10;            progressBar.visibility = View.GONE&#10;            btnRefresh.visibility = View.VISIBLE&#10;            return&#10;        }&#10;        val priority = effectivePriority()&#10;        val fineGranted = ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED&#10;        val request = LocationRequest.Builder(priority, 1000L)&#10;            .setMinUpdateIntervalMillis(0L)&#10;            .setMaxUpdateDelayMillis(1000L)&#10;            .setGranularity(com.google.android.gms.location.Granularity.GRANULARITY_PERMISSION_LEVEL)&#10;            .setWaitForAccurateLocation(fineGranted)&#10;            .setDurationMillis(10_000L)&#10;            .setMaxUpdates(3) // dovol pár pokusů, aby se dohonila změna v emulátoru&#10;            .build()&#10;&#10;        val callback = object : LocationCallback() {&#10;            override fun onLocationResult(result: LocationResult) {&#10;                val loc = result.lastLocation&#10;                if (loc != null) {&#10;                    Log.d(&quot;Location&quot;, &quot;requestUpdate lat=${loc.latitude} lon=${loc.longitude} t=${loc.time} acc=${loc.accuracy}&quot;)&#10;                    fusedLocationClient.removeLocationUpdates(this)&#10;                    handleLocation(loc, shouldSave)&#10;                }&#10;            }&#10;        }&#10;        fusedLocationClient.requestLocationUpdates(request, callback, Looper.getMainLooper())&#10;    }&#10;&#10;    private fun handleLocation(location: Location, shouldSave: Boolean) {&#10;        lastLat = location.latitude&#10;        lastLon = location.longitude&#10;        tvCoordinates.text = &quot;Lat: %.5f, Lon: %.5f&quot;.format(location.latitude, location.longitude)&#10;        lifecycleScope.launch {&#10;            val address = getAddressFromLocation(location)&#10;            tvLocation.text = address ?: &quot;Adresa nenalezena&quot;&#10;            lastAddress = address&#10;            getWeather(address, shouldSave)&#10;        }&#10;    }&#10;&#10;    private fun getWeather(address: String?, shouldSave: Boolean) {&#10;        val lat = lastLat&#10;        val lon = lastLon&#10;        if (lat == null || lon == null) {&#10;            tvWeather.text = &quot;Počasí: --&quot;&#10;            Log.e(&quot;Weather&quot;, &quot;Souřadnice nejsou k dispozici&quot;)&#10;            progressBar.visibility = View.GONE&#10;            btnRefresh.visibility = View.VISIBLE&#10;            return&#10;        }&#10;&#10;        val sharedPreferences = getSharedPreferences(&quot;settings&quot;, MODE_PRIVATE)&#10;        val unit = sharedPreferences.getString(&quot;unit&quot;, &quot;metric&quot;) ?: &quot;metric&quot;&#10;&#10;        weatherApi.getWeather(lat, lon, weatherApiKey, unit).enqueue(object : Callback&lt;WeatherResponse&gt; {&#10;            override fun onResponse(call: Call&lt;WeatherResponse&gt;, response: Response&lt;WeatherResponse&gt;) {&#10;                if (!response.isSuccessful) {&#10;                    tvWeather.text = &quot;Počasí: --&quot;&#10;                    Log.e(&quot;Weather&quot;, &quot;Chyba HTTP: ${response.code()} ${response.message()}&quot;)&#10;                    progressBar.visibility = View.GONE&#10;                    btnRefresh.visibility = View.VISIBLE&#10;                    return&#10;                }&#10;                val body = response.body()&#10;                if (body != null) {&#10;                    val desc = body.weather.firstOrNull()?.description ?: &quot;--&quot;&#10;                    val temp = body.main.temp&#10;                    val unitSymbol = if (unit == &quot;imperial&quot;) &quot;°F&quot; else &quot;°C&quot;&#10;                    val weatherText = &quot;Počasí: $temp$unitSymbol, $desc&quot;&#10;                    tvWeather.text = weatherText&#10;                    lastWeather = weatherText&#10;                    // Uložení do historie&#10;                    if (shouldSave) {&#10;                        val lat = lastLat&#10;                        val lon = lastLon&#10;                        if (lat != null &amp;&amp; lon != null) {&#10;                            val defaultNote = sharedPreferences.getString(&quot;default_note&quot;, &quot;&quot;)&#10;                            lifecycleScope.launch {&#10;                                repository.insert(&#10;                                    LocationRecord(&#10;                                        latitude = lat,&#10;                                        longitude = lon,&#10;                                        timestamp = System.currentTimeMillis(),&#10;                                        address = address ?: &quot;Neznámá adresa&quot;,&#10;                                        weather = weatherText,&#10;                                        note = defaultNote&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                    Log.d(&quot;Weather&quot;, &quot;Úspěch: $temp$unitSymbol, $desc&quot;)&#10;                } else {&#10;                    tvWeather.text = &quot;Počasí: --&quot;&#10;                    Log.e(&quot;Weather&quot;, &quot;Tělo odpovědi je null&quot;)&#10;                }&#10;                progressBar.visibility = View.GONE&#10;                btnRefresh.visibility = View.VISIBLE&#10;            }&#10;            override fun onFailure(call: Call&lt;WeatherResponse&gt;, t: Throwable) {&#10;                tvWeather.text = &quot;Počasí: --&quot;&#10;                Log.e(&quot;Weather&quot;, &quot;Chyba volání: ${t.message}&quot;, t)&#10;                progressBar.visibility = View.GONE&#10;                btnRefresh.visibility = View.VISIBLE&#10;            }&#10;        })&#10;    }&#10;&#10;    private fun saveCurrentLocation() {&#10;        if (lastLat != null &amp;&amp; lastLon != null &amp;&amp; lastAddress != null) {&#10;            val sharedPreferences = getSharedPreferences(&quot;settings&quot;, MODE_PRIVATE)&#10;            val defaultNote = sharedPreferences.getString(&quot;default_note&quot;, &quot;&quot;)&#10;            val record = LocationRecord(&#10;                latitude = lastLat!!,&#10;                longitude = lastLon!!,&#10;                timestamp = System.currentTimeMillis(),&#10;                address = lastAddress!!,&#10;                weather = lastWeather,&#10;                note = defaultNote&#10;            )&#10;            lifecycleScope.launch {&#10;                repository.insert(record)&#10;                Toast.makeText(this@MainActivity, &quot;Poloha uložena&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        } else {&#10;            Toast.makeText(this, &quot;Nelze uložit, data o poloze nejsou k dispozici.&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    @RequiresPermission(allOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;        if (requestCode == 100) {&#10;            val fineGranted = ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED&#10;            val coarseGranted = ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED&#10;            if (fineGranted || coarseGranted) {&#10;                getLastLocation(true)&#10;            } else {&#10;                Toast.makeText(this, &quot;Bez povolení polohy nelze získat souřadnice.&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getAddressFromLocation(location: Location): String? {&#10;        return try {&#10;            val addresses = geocoder.getFromLocation(location.latitude, location.longitude, 1)&#10;            if (addresses?.isNotEmpty() == true) {&#10;                addresses[0].getAddressLine(0)&#10;            } else null&#10;        } catch (e: IOException) {&#10;            Log.e(&quot;Geocoder&quot;, &quot;Nelze získat adresu&quot;, e)&#10;            null&#10;        }&#10;    }&#10;}&#10;&#10;// --- OpenWeatherMap API rozhraní ---&#10;interface WeatherApi {&#10;    @GET(&quot;weather&quot;)&#10;    fun getWeather(&#10;        @Query(&quot;lat&quot;) lat: Double,&#10;        @Query(&quot;lon&quot;) lon: Double,&#10;        @Query(&quot;appid&quot;) apiKey: String,&#10;        @Query(&quot;units&quot;) units: String,&#10;        @Query(&quot;lang&quot;) lang: String = &quot;cz&quot;&#10;    ): Call&lt;WeatherResponse&gt;&#10;}&#10;&#10;data class WeatherResponse(&#10;    val weather: List&lt;WeatherDesc&gt;,&#10;    val main: MainWeather&#10;)&#10;data class WeatherDesc(val description: String)&#10;data class MainWeather(val temp: Double)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/knowmyspot/data/LocationDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/knowmyspot/data/LocationDao.kt" />
              <option name="originalContent" value="package com.example.knowmyspot.data&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Insert&#10;import androidx.room.Query&#10;import androidx.room.Update&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface LocationDao {&#10;    @Insert&#10;    suspend fun insert(locationRecord: LocationRecord)&#10;&#10;    @Query(&quot;SELECT * FROM location_records ORDER BY timestamp DESC&quot;)&#10;    fun getAllRecords(): Flow&lt;List&lt;LocationRecord&gt;&gt;&#10;&#10;    @Update&#10;    suspend fun update(locationRecord: LocationRecord)&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.knowmyspot.data&#10;&#10;// Tento soubor je nyní prázdný, protože Room se již nepoužívá." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>